---

# Heap 2

## Overview
In this CTF challenge, we are given a vulnerable binary that contains a buffer overflow vulnerability. The goal is to exploit this vulnerability to execute the `win()` function and obtain the flag.

## Steps to Solve
1. **Initial Analysis**: Start by examining the provided source code to understand the vulnerability. In this case, the `check_win()` function casts the variable `x` as a function pointer, indicating a potential buffer overflow vulnerability.

2. **Crafting the Payload**: Use a debugger such as GDB to analyze the program's behavior and determine the offset needed to overwrite the return address. Create a pattern of input (e.g., using `pattern create` in GDB) and input it into the vulnerable buffer and then use the print_flag function to cause a cras(since it uses x).

3. **Finding the Offset**: Analyze the crash to determine the offset needed to overwrite the return address. Use the `pattern offset` command in GDB to find the offset from the start of the pattern to the point where the pattern is found inside the `x` variable.

4. **Finding the Address of the `win()` Function**: Use the `nm` or `readelf` command to check for stripped symbols in the binary. Look for the address of the `win()` function, which is the target function to execute.

5. **Crafting the Final Payload**: Use Python with pwntools to craft a payload that consists of padding (`b'A' * offset`) followed by the address of the `win()` function in little-endian form.

6. **Testing the Payload**: After testing your payload locally and ensuring that it works, send the crafted payload to the server see if it successfully executes the `win()` function and prints the flag.

7. **Refining the Payload**: If the payload does not work as expected, refine it by adjusting the offset or other parameters until the `win()` function is successfully executed and the flag is obtained.

---
